#include "SolverCG.h"
#include "LidDrivenCavity.h"

#include <iostream>
#include <iomanip>
#include <fstream>
#include <cstring>
#include <cmath>
#include<array>
#include <cstdlib> 
using namespace std;

#define IDX(I,J) ((J)*Nx + (I))

#define BOOST_TEST_MODULE testSolverCG
#include <boost/test/included/unit_test.hpp>
//Notes Example 8.1

//Funciton to initialise MPI for boost
bool init_unit_test() {

    //get the argc and argv from the main fuction auto generated by boost, helped developed by generative ai tool
    int argc = boost::unit_test::framework::master_test_suite().argc;
    char** argv = boost::unit_test::framework::master_test_suite().argv;



    // Initialize MPI
    MPI_Init(&argc, &argv);

    return true; 
}

//function test solve member function
BOOST_AUTO_TEST_CASE( Solver )
{  
    init_unit_test();
    //Get rank of current porcess
    int rank1=-1;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank1);

    int Nx = 9;
    int Ny = 9;
    int Npts = Nx*Ny;
    double dx = 0.01;
    double dy = 0.01;
    double s[Npts] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.000449202, -0.000836013, -0.00111236, -0.00124963, -0.00123722, -0.00108004, -0.000797448, -0.000422762, 0, -0.000960795, -0.00178249, -0.0023638, -0.00264892, -0.00261923, -0.0022855, -0.00168699, -0.0008936, 0, -0.00161148, -0.00296937, -0.00391142, -0.00436303, -0.00430528, -0.00375572, -0.00277141, -0.00146465, 0, -0.00251576, -0.00457209, -0.00594947, -0.00658648, -0.00648314, -0.00566072, -0.00417826, -0.0021936, 0, -0.00387948, -0.00685377, -0.00872789, -0.00955031, -0.00938007, -0.00822574, -0.00608733, -0.00313147, 0, -0.00614838, -0.0102356, -0.012558, -0.0135068, -0.0132611, -0.0117749, -0.00881384, -0.00424497, 0, -0.0104784, -0.0153823, -0.0177617, -0.0186578, -0.0183826, -0.0167988, -0.0131482, -0.00503455, 0, -0.00438298, -0.00705352, -0.00844878, -0.00897987, -0.00881297, -0.00788934, -0.00594565, -0.00274505
    };
    double v[Npts] = {
-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -1.57336, -3.13276, -4.66434, -6.15453, -7.59009, -8.95828, -10.247, -11.4447, -0, -3.13276, -6.2377, -9.28729, -12.2544, -15.1128, -17.837, -20.403, -22.7878, -0, -4.66434, -9.28729, -13.8278, -18.2456, -22.5014, -26.5575, -30.3779, -33.9286, -0, -6.15453, -12.2544, -18.2456, -24.0748, -29.6902, -35.0422, -40.0831, -44.7683, -0, -7.59009, -15.1128, -22.5014, -29.6902, -36.6156, -43.2159, -49.4326, -55.2106, -0, -8.95828, -17.837, -26.5575, -35.0422, -43.2159, -51.006, -58.3433, -65.1628, -0, -10.247, -20.403, -30.3779, -40.0831, -49.4326, -58.3433, -66.7362, -74.5367, -0, -11.4447, -22.7878, -33.9286, -44.7683, -55.2106, -65.1628, -74.5367, -83.249    };
    double vSin[Npts] = {};



    SolverCG* cg  = new SolverCG(Nx, Ny, dx, dy);



    // Sinusoidal test case with analytical solution, which can be used to test
    // the Poisson solver
    const int k = 3;
    const int l = 3;
    for (int i = 0; i < Nx; ++i) {
        for (int j = 0; j < Ny; ++j) {
            vSin[IDX(i,j)] = -M_PI * M_PI * (k * k + l * l)
                                       * sin(M_PI * k * i * dx)
                                       * sin(M_PI * l * j * dy);
        }
    }


    // Solve Poisson problem
        cg->Solve(vSin, s);

    // //Probes for v
    // if (rank1==0){
    //     cout<< "v from SolverCG = ";
    //     for (int i=0; i<Npts; i++){
    //         cout<< v[i] << ", ";  
    //     }
    //     cout<<endl;
    //     cout<< "v from test = ";
    //     for (int i=0; i<Npts; i++){
    //         cout<< vSin[i] << ", ";  
    //     }
    //     cout<<endl;
    // }
    // //

    
    int indicator = 0;

    for (int i=0; i<Npts; i++){
        if(abs(vSin[i]!=v[i])>50){
            indicator = 1;
        }
    }

    BOOST_CHECK( indicator == 0 );
}

//function test subIDXglobal in liddrivencavity class
BOOST_AUTO_TEST_CASE( subIDXglobal )
{  
    //Get rank of current porcess
    int rank1=-1;
    int size1=-1;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank1);
    MPI_Comm_size(MPI_COMM_WORLD, &size1);

    int Nx = 9;
    int Ny = 9;
    int Npts = Nx*Ny;
    double dx = 0.01;
    double dy = 0.01;
    double s[Npts] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.000449202, -0.000836013, -0.00111236, -0.00124963, -0.00123722, -0.00108004, -0.000797448, -0.000422762, 0, -0.000960795, -0.00178249, -0.0023638, -0.00264892, -0.00261923, -0.0022855, -0.00168699, -0.0008936, 0, -0.00161148, -0.00296937, -0.00391142, -0.00436303, -0.00430528, -0.00375572, -0.00277141, -0.00146465, 0, -0.00251576, -0.00457209, -0.00594947, -0.00658648, -0.00648314, -0.00566072, -0.00417826, -0.0021936, 0, -0.00387948, -0.00685377, -0.00872789, -0.00955031, -0.00938007, -0.00822574, -0.00608733, -0.00313147, 0, -0.00614838, -0.0102356, -0.012558, -0.0135068, -0.0132611, -0.0117749, -0.00881384, -0.00424497, 0, -0.0104784, -0.0153823, -0.0177617, -0.0186578, -0.0183826, -0.0167988, -0.0131482, -0.00503455, 0, -0.00438298, -0.00705352, -0.00844878, -0.00897987, -0.00881297, -0.00788934, -0.00594565, -0.00274505
    };
    double v[Npts] = {
-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -1.57336, -3.13276, -4.66434, -6.15453, -7.59009, -8.95828, -10.247, -11.4447, -0, -3.13276, -6.2377, -9.28729, -12.2544, -15.1128, -17.837, -20.403, -22.7878, -0, -4.66434, -9.28729, -13.8278, -18.2456, -22.5014, -26.5575, -30.3779, -33.9286, -0, -6.15453, -12.2544, -18.2456, -24.0748, -29.6902, -35.0422, -40.0831, -44.7683, -0, -7.59009, -15.1128, -22.5014, -29.6902, -36.6156, -43.2159, -49.4326, -55.2106, -0, -8.95828, -17.837, -26.5575, -35.0422, -43.2159, -51.006, -58.3433, -65.1628, -0, -10.247, -20.403, -30.3779, -40.0831, -49.4326, -58.3433, -66.7362, -74.5367, -0, -11.4447, -22.7878, -33.9286, -44.7683, -55.2106, -65.1628, -74.5367, -83.249    };
    double vSin[Npts] = {};

    LidDrivenCavity* solver = new LidDrivenCavity();
    
    solver->SetSubCore();

    int indicator = 0;

    if (size1 == 1 && v[solver->subIDXglobal(16, 0)] !=-10.247){
        indicator = -1;
    }
    else if (size1 == 4 && v[solver->subIDXglobal(12, 3)] != -51.006){
        indicator = -1;
    }
    else if (size1 == 9 && v[solver->subIDXglobal(10, 6)] != 0){
        indicator = -1;
    }
    else if (size1 == 16 && v[solver->subIDXglobal(12, 12)] != -0.0008936){        
        indicator = -1;

    }
    


    BOOST_CHECK( indicator == 0 );
}


//function test Advance in liddrivencavity class
BOOST_AUTO_TEST_CASE( Advance )
{  
    //Get rank of current porcess
    int rank=-1;
    int size=-1;
    int mygrid_rank = -1;
    MPI_Comm mygrid;
    MPI_Comm myrowcomm, mycolcomm;
    int coords[2];
    int* subGridNumArray = nullptr;
    int* subSideNumXArray = nullptr;
    int* subSideNumYArray = nullptr;



    int Nx = 9;
    int Ny = 9;
    int Npts = Nx*Ny;
    double dx = 0.01;
    double dy = 0.01;
    double dt   = 0.01;
    double T    = 1.0;

    double s[Npts] = {
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    };
    double v[Npts] = {
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    };
    
    double vSin[Npts] = {};

 
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    MPI_Comm_size(MPI_COMM_WORLD, &size);

    //num of process per each side
    int sideSubCoreNum = sqrt(size);

    if (rank == 0 && sideSubCoreNum*sideSubCoreNum != size){
        cout<<"ABORTED. NUMBER OF PROCESS MUST BE A SQURE VALUE."<<endl;
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    //cout << "Process Number = "<< rank+1<< " of " << size << endl;
    //Note Example 12.3

    //Note Example 12.8
    int sizes[2] = {sideSubCoreNum, sideSubCoreNum};
    int periods[2] = {0, 0};
    int reorder = 1;
    MPI_Cart_create(MPI_COMM_WORLD, 2, sizes, periods, reorder, &mygrid);

    MPI_Comm_rank(mygrid, &mygrid_rank);
    MPI_Cart_coords(mygrid, mygrid_rank, 2, coords);

    int subSideNumX = 0;
    int subSideNumY = 0;

    //num of grid per each side of sub
    int subSideNum = Nx/sideSubCoreNum;
    if (coords[1]==sideSubCoreNum-1){
        subSideNumX=Nx/sideSubCoreNum+Nx%sideSubCoreNum;
    }
    else{
        subSideNumX = Nx/sideSubCoreNum;
    }
    if (coords[0]==sideSubCoreNum-1){
        subSideNumY=Ny/sideSubCoreNum+Ny%sideSubCoreNum;
    }
    else{
        subSideNumY = Ny/sideSubCoreNum;
    }

    //num of grid per sub process
    int subGridNum = subSideNumX*subSideNumY;
    //cout<<"subGridNum = " << subGridNum << endl;

    //Record Sub Processes Size at Process 0
    if (mygrid_rank!=0){
        int subGridNumSend = subGridNum;
        MPI_Send(&subGridNumSend, 1, MPI_INT, 0, 100, MPI_COMM_WORLD);
    }
    else if (mygrid_rank==0){
        //store the num of grid of each sub process
        subGridNumArray = new int[size]();
        subGridNumArray[0] = subGridNum;
        for (int i=1; i<size; i++){
            int subGridNumRecv=0;
            MPI_Recv(&subGridNumRecv, 1, MPI_INT, i, 100, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            subGridNumArray[i]=subGridNumRecv;  
        }
    }


    subSideNumYArray = new int[size]();
    subSideNumXArray = new int[size]();
    //Record Sub Prcesses Dimensions at Process 0    
    if (mygrid_rank!=0){
        int subSideNumXSend = subSideNumX;
        int subSideNumYSend = subSideNumY;
        MPI_Send(&subSideNumXSend, 1, MPI_INT, 0, 101, MPI_COMM_WORLD);
        MPI_Send(&subSideNumYSend, 1, MPI_INT, 0, 102, MPI_COMM_WORLD);
    }
    else if (mygrid_rank==0){
        //store the num of grid of each sub process
        subSideNumXArray[0] = subSideNumX;
        subSideNumYArray[0] = subSideNumY;
        for (int i=1; i<size; i++){
            int subSideNumXRecv=0;
            int subSideNumYRecv=0;
            MPI_Recv(&subSideNumXRecv, 1, MPI_INT, i, 101, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            MPI_Recv(&subSideNumYRecv, 1, MPI_INT, i, 102, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            subSideNumXArray[i]=subSideNumXRecv; 
            subSideNumYArray[i]=subSideNumYRecv;  
        }
    }
    
     MPI_Bcast(subSideNumXArray, size, MPI_INT, 0, MPI_COMM_WORLD);
     MPI_Bcast(subSideNumYArray, size, MPI_INT, 0, MPI_COMM_WORLD);


    LidDrivenCavity* solver = new LidDrivenCavity();
    SolverCG* cg  = new SolverCG(Nx, Ny, dx, dy);

    solver->SetSubCore();


    for (int t = 0; t < 1; ++t)//<NSteps
    {
        if (mygrid_rank==0){
            std::cout << "Step: " << setw(8) << t << "  Time: " << setw(8) << t*dt << std::endl;
            //t is Step, t*dt is time
        }

        solver->Advance(v,s, cg, dx, dy);
    }

    int indicator2 = 0;

    if (size == 1 && v[solver->subIDXglobal(12, 0)]!=0){
        indicator2 = -1;

    }
    else if (size == 4 && v[solver->subIDXglobal(12, 3)] != 0){
        indicator2 = -1;

    }
    else if (size == 9 && v[solver->subIDXglobal(6, 5)]!=0){
        indicator2 = -1;
    }
    else if (size == 16 && v[solver->subIDXglobal(6, 5)]!=0){        
        indicator2 = -1;
    }
    
    MPI_Finalize();
    


    BOOST_CHECK( indicator2 == 0 );
}


